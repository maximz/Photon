An SQL join clause combines records from two or more tables in a database. It creates a set that can be saved as a table or used as it is. A codice_1 is a means for combining fields from two tables by using values common to each. ANSI standard SQL specifies four types of codice_1: codice_3, codice_4, codice_5, and codice_6. As a special case, a table (base table, view, or joined table) can codice_1 to itself in a "self-join".
A programmer writes a codice_1 predicate to identify the records for joining. If the evaluated predicate is true, the combined record is then produced in the expected format, a record set or a temporary table.
Sample tables.
Relational databases are often normalized to eliminate duplication of information when objects may have one-to-many relationships. For example, a Department may be associated with many different Employees. Joining two tables effectively creates another table which combines information from both tables. This is at some expense in terms of the time it takes to compute the join. While it is also possible to simply maintain a denormalized table if speed is important, duplicate information may take extra space, and add the expense and complexity of maintaining data integrity if data which is duplicated later changes.
All subsequent explanations on join types in this article make use of the following two tables. The rows in these tables serve to illustrate the effect of different types of joins and join-predicates. In the following tables the codice_9 column of the codice_10 table (which can be designated as codice_11) is the primary key, while codice_12 is a foreign key.
Note: In the Employee table above, the employee "John" has not been assigned to any department yet. Also, note that no employees are assigned to the "Marketing" department.
This is the SQL to create the aforementioned tables.
CREATE TABLE department
CREATE TABLE employee
INSERT INTO department(DepartmentID, DepartmentName) VALUES(31, 'Sales');
INSERT INTO department(DepartmentID, DepartmentName) VALUES(33, 'Engineering');
INSERT INTO department(DepartmentID, DepartmentName) VALUES(34, 'Clerical');
INSERT INTO department(DepartmentID, DepartmentName) VALUES(35, 'Marketing');
INSERT INTO employee(LastName, DepartmentID) VALUES('Rafferty', 31);
INSERT INTO employee(LastName, DepartmentID) VALUES('Jones', 33);
INSERT INTO employee(LastName, DepartmentID) VALUES('Steinberg', 33);
INSERT INTO employee(LastName, DepartmentID) VALUES('Robinson', 34);
INSERT INTO employee(LastName, DepartmentID) VALUES('Smith', 34);
INSERT INTO employee(LastName, DepartmentID) VALUES('John', NULL);
</source>
Cross join.
CROSS JOIN returns the Cartesian product of rows from tables in the join. In other words, it will produce rows which combine each row from the first table with each row from the second table.
SELECT *
FROM employee CROSS JOIN department;
</source>
SELECT *
FROM employee, department;
</source>
The cross join does not apply any predicate to filter records from the joined table. Programmers can further filter the results of a cross join by using a codice_13 clause.
In the standard, cross joins are part of the optional F401, “Extended joined table”, package.
Inner join.
An inner join is the most common join operation used in applications and can be regarded as the default join-type. Inner join creates a new result table by combining column values of two tables (A and B) based upon the join-predicate. The query compares each row of A with each row of B to find all pairs of rows which satisfy the join-predicate. When the join-predicate is satisfied, column values for each matched pair of rows of A and B are combined into a result row. The result of the join can be defined as the outcome of first taking the Cartesian product (or Cross join) of all records in the tables (combining every record in table A with every record in table B)—then return all records which satisfy the join predicate. Actual SQL implementations normally use other approaches like a hash join or a sort-merge join where possible, since computing the Cartesian product is very inefficient.
SQL specifies two different syntactical ways to express joins: "explicit join notation" and "implicit join notation".
SELECT *
FROM employee INNER JOIN department
</source>
The "implicit join notation" simply lists the tables for joining, in the codice_16 clause of the codice_17 statement, using commas to separate them. Thus it specifies a cross join, and the codice_13 clause may apply additional filter-predicates (which function comparably to the join-predicates in the explicit notation).
SELECT *
FROM employee, department
WHERE employee.DepartmentID = department.DepartmentID;
</source>
The queries given in the examples above will join the Employee and Department tables using the DepartmentID column of both tables. Where the DepartmentID of these tables match (i.e. the join-predicate is satisfied), the query will combine the "LastName", "DepartmentID" and "DepartmentName" columns from the two tables into a result row. Where the DepartmentID does not match, no result row is generated.
Note: Programmers should take special care when joining tables on columns that can contain NULL values, since NULL will never match any other value (not even NULL itself), unless the join condition explicitly uses the codice_19 or codice_20 predicates.
Notice that the employee "John" and the department "Marketing" do not appear in the query execution results. Neither of these has any matching records in the other respective table: "John" has no associated department, and no employee has the department ID 35 ("Marketing"). Depending on the desired results, this behavior may be a subtle bug, which can be avoided with an outer join.
One can further classify inner joins as equi-joins, as natural joins, or as cross-joins.
Equi-join.
SELECT *
FROM employee JOIN department
</source>
We can write equi-join as below,
SELECT *
FROM employee, department
WHERE employee.DepartmentID = department.DepartmentID;
</source>
SELECT *
FROM employee INNER JOIN department USING (DepartmentID);
</source>
The codice_22 construct is more than mere syntactic sugar, however, since the result set differs from the result set of the version with the explicit predicate. Specifically, any columns mentioned in the codice_22 list will appear only once, with an unqualified name, rather than once for each table in the join. In the above case, there will be a single codice_9 column and no codice_26 or codice_27.
The codice_22 clause is not supported by SQL Server and Sybase.
Natural join.
A natural join is a type of equi-join where the join predicate arises implicitly by comparing all columns in both tables that have the same column-names in the joined tables. The resulting joined table contains only one column for each pair of equally named columns.
Most experts agree that NATURAL JOINs are dangerous and therefore strongly discourage their use. The danger comes from inadvertently adding a new column, named the same as another column in the other table. An existing natural join might then "naturally" use the new column for comparisons, making comparisons/matches using different criteria (from different columns) than before. Thus an existing query could produce different results, even though the data in the tables have not been changed, but only augmented.
SELECT *
FROM employee NATURAL JOIN department;
</source>
PostgreSQL, MySQL and Oracle support natural joins, but not Microsoft T-SQL or IBM DB2. The columns used in the join are implicit so the join code does not show which columns are expected, and a change in column names may change the results. An INNER JOIN performed on 2 tables having the same field name has the same effect. In the standard, natural joins are part of the optional F401, “Extended joined table”, package.
Outer joins.
An outer join does not require each record in the two joined tables to have a matching record. The joined table retains each record—even if no other matching record exists. Outer joins subdivide further into left outer joins, right outer joins, and full outer joins, depending on which table's rows are retained (left, right, or both).
No implicit join-notation for outer joins exists in standard SQL.
Left outer join.
The result of a "left outer join" (or simply left join) for table A and B always contains all records of the "left" table (A), even if the join-condition does not find any matching record in the "right" table (B). This means that if the codice_15 clause matches 0 (zero) records in B (for a given record in A), the join will still return a row in the result (for that record)—but with NULL in each column from B. A left outer join returns all the values from an inner join plus all values in the left table that do not match to the right table. From Oracle 9i onwards the LEFT OUTER JOIN statement can be used as well as Oracle's older (+) syntax.
For example, this allows us to find an employee's department, but still shows the employee(s) even when they have not been assigned to a department (contrary to the inner-join example above, where unassigned employees were excluded from the result).
SELECT *
FROM employee LEFT OUTER JOIN department
</source>
SELECT *
FROM employee, department
WHERE employee.DepartmentID = department.DepartmentID(+)
</source>
SELECT *
FROM employee, department
WHERE employee.DepartmentID *= department.DepartmentID
</source>
Right outer join.
A right outer join (or right join) closely resembles a left outer join, except with the treatment of the tables reversed. Every row from the "right" table (B) will appear in the joined table at least once. If no matching row from the "left" table (A) exists, NULL will appear in columns from A for those records that have no match in B.
A right outer join returns all the values from the right table and matched values from the left table (NULL in case of no matching join predicate). For example, this allows us to find each employee and his or her department, but still show departments that have no employees.
SELECT *
FROM employee RIGHT OUTER JOIN department
</source>
SELECT *
FROM employee, department
WHERE employee.DepartmentID(+) = department.DepartmentID
</source>
Right and left outer joins are functionally equivalent. Neither provides any functionality that the other does not, so right and left outer joins may replace each other as long as the table order is switched.
Full outer join.
Conceptually, a full outer join combines the effect of applying both left and right outer joins. Where records in the FULL OUTER JOINed tables do not match, the result set will have NULL values for every column of the table that lacks a matching row. For those records that do match, a single row will be produced in the result set (containing fields populated from both tables).
For example, this allows us to see each employee who is in a department and each department that has an employee, but also see each employee who is not part of a department and each department which doesn't have an employee.
SELECT *
FROM employee FULL OUTER JOIN department
</source>
SELECT employee.LastName, employee.DepartmentID,
FROM employee
INNER JOIN department ON employee.DepartmentID = department.DepartmentID
UNION ALL
SELECT employee.LastName, employee.DepartmentID,
FROM employee
WHERE NOT EXISTS (
UNION ALL
SELECT cast(NULL as varchar(20)), cast(NULL as integer),
FROM department
WHERE NOT EXISTS (
</source>
Self-join.
A self-join is joining a table to itself.
Example.
A query to find all pairings of two employees in the same country is desired. If there were two separate tables for employees and a query which requested employees in the first table having the same country as employees in the second table, a normal join operation could be used to find the answer table. However, all the employee information is contained within a single large table.
SELECT F.EmployeeID, F.LastName, S.EmployeeID, S.LastName, F.Country
FROM Employee F INNER JOIN Employee S ON F.Country = S.Country
WHERE F.EmployeeID < S.EmployeeID
ORDER BY F.EmployeeID, S.EmployeeID;
</source>
Which results in the following table being generated.
Only one of the two middle pairings is needed to satisfy the original question, and the topmost and bottommost are of no interest at all in this example.
Merge rows.
To be able to do a select so as to merge multiple rows into 1 row : "group_concat notation".
MySQL and CUBRID use the codice_39 keyword to achieve that goal, and PostgreSQL 9.0 has the codice_40 function. Versions before 9.0 required the use of something like
or the creation of an aggregate function.
MySQL.
SELECT DepartmentID, group_concat(LastName) as LastNames
FROM employee
GROUP BY DepartmentID;
</source>
Oracle 11g R2.
SELECT DepartmentID,
FROM employee
GROUP BY DepartmentID;
</source>
CUBRID.
SELECT DepartmentID,
FROM employee
GROUP BY DepartmentID;
</source>
PostgreSQL.
First the function _group_concat and aggregate group_concat need to be created before that query can be possible.
CREATE OR REPLACE FUNCTION _group_concat(text, text)
RETURNS text AS $$
SELECT CASE
WHEN $2 IS NULL THEN $1
WHEN $1 IS NULL THEN $2
ELSE $1 operator(pg_catalog.||) ', ' operator(pg_catalog.||) $2
END
$$ IMMUTABLE LANGUAGE SQL;
error// Join SQL
CREATE AGGREGATE group_concat (
BASETYPE = text,
SFUNC = _group_concat,
STYPE = text
SELECT DepartmentID, group_concat(LastName) as LastNames
FROM employee
GROUP BY DepartmentID;
</source>
SELECT DepartmentID, string_agg(LastName, ', ') as LastNames
FROM employee
GROUP BY DepartmentID;
</source>
Microsoft T-SQL.
For versions prior to Microsoft SQL Server 2005, the function group_concat must be created as a user-defined aggregate function before that query can be possible, shown here in C#.
using System;
using System.Collections.Generic;
using System.Data.SqlTypes;
using System.IO;
using Microsoft.SqlServer.Server;
MaxByteSize=8000)
public struct group_concat : IBinarySerialize{
</source>
SELECT DepartmentID, dbo.group_concat(LastName) as LastNames
FROM employee
GROUP BY DepartmentID;
</source>
SELECT DepartmentID,
FROM employee e1
GROUP BY DepartmentID
</source>
Alternatives.
The effect of an outer join can also be obtained using a UNION ALL between an INNER JOIN and a SELECT of the rows in the "main" table that do not fulfill the join condition. For example
SELECT employee.LastName, employee.DepartmentID, department.DepartmentName
FROM employee
LEFT OUTER JOIN department ON employee.DepartmentID = department.DepartmentID;
</source>
can also be written as
SELECT employee.LastName, employee.DepartmentID, department.DepartmentName
FROM employee
INNER JOIN department ON employee.DepartmentID = department.DepartmentID
UNION ALL
SELECT employee.LastName, employee.DepartmentID, cast(NULL as varchar(20))
FROM employee
WHERE NOT EXISTS (
</source>
Implementation.
Many join-algorithms treat their inputs differently. One can refer to the inputs to a join as the "outer" and "inner" join operands, or "left" and "right", respectively. In the case of nested loops, for example, the database system will scan the entire inner relation for each row of the outer relation.
These names derive from the appearance of the query plan if drawn as a tree, with the outer join relation on the left and the inner relation on the right (as convention dictates).
Join algorithms.
Three fundamental algorithms for performing a join operation exist: nested loop join, sort-merge join and hash join.
Join Indexes.
Join indexes are database indexes that facilitate the processing of join queries in data warehouses: they are currently (2012) available in implementations by Oracle and Teradata.
In the Teradata implementation, specified columns, aggregate functions on columns, or components of date columns from one or more tables are specified using a syntax similar to the definition of a database view: up to 64 columns/column expressions can be specified in a single join index. Optionally, a column that defines the primary key of the composite data may also be specified: on parallel hardware, the column values are used to partition the index's contents across multiple disks. When the source tables are updated interactively by users, the contents of the join index are automatically updated. Any query whose WHERE clause specifies any combination of columns or column expressions that are an exact subset of those defined in a join index (a so-called "covering query" will cause the join index, rather than the original tables and their indexes, to be consulted during query execution.
The Oracle implementation limits itself to using bitmap indexes. A "bitmap join index" is used for low-cardinality columns (i.e., columns containing less than 300 distinct values, according to the Oracle documentation): it combines low-cardinality columns from multiple related tables. The example Oracle uses is that of an inventory system, where different suppliers provide different parts. The schema has three linked tables: two "master tables", Part and Supplier, and a "detail table", Inventory. The last is a many-to-many table linking Supplier to Part, and contains the most rows. Every part has a Part Type, and every supplier is based in the USA, and has a State column. There are not more than 60 states+territories in the USA, and not more than 300 Part Types. The bitmap join index is defined using a standard three-table join on the above three tables, and specifying the Part_Type and Supplier_State columns for the index. However, it is defined on the Inventory table, even though the columns Part_Type and Supplier_State are "borrowed" from Supplier and Part respectively.
As for Teradata, an Oracle bitmap join index is only utilized to answer a query when the query's WHERE clause specifies columns limited to those that are included in the join index.
